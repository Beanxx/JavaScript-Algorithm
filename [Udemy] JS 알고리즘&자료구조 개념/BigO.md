## Section 2. 빅오 표기법(Big O Notation)

- 수동으로 걸리는 시간을 측정하는건 좋은 방법 X <br>
  👉 시간을 비교하는 특정한 값이 있었으면 좋겠음 👉 Big O

- 즉, 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것 대신에 컴퓨터가 처리해야 하는 연산 갯수를 세면 됨!

- 연산 하나하나 세는게 중요한게 아니라 전체적인 큰 그림이 중요!

- for문 내의 += 연산은 각각 n연산으로 셈

- n이 커질수록 연산 갯수도 비례적으로 늘어남

> 🧐 <strong>빅오(Big O)</strong>란? <br/>
> : 입력된 내용이 늘어날수록 알고리즘 실행 시간이 어떻게 변하는지 설명하는 공식적인 방식 <br/><br/>
> ➰ 실행시간이 갖을 수 있는 최대치 (일반적으로 가장 높은 실행 시간 값들을 말함)

1. O(1): n의 값이 커질수록, 아무 변화가 없음을 의미 (실행 시간은 변하지 않음)

2. O(n): n이 커질수록 실행 시간이 1:1 비율로 늘어남

3. O(n^2): n이 커질수록 실행 시간이 n^2으로 늘어남 → 지수 곡선 (ex. 이중 for문)

> O(2n) -> O(n) <br/>
> O(500) -> O(1) <br/>
> O(13n^2) -> O(n^2) <br/>
> O(1000n + 50) -> O(n) <br/>
> O(n^2 + 5n + 8) -> O(n^2)

<br/>

✎ <strong>시간 복잡도에 대한 Big O</strong>

1. 산수(+, - , \*, /) → 상수
2. 변수 배정 → 상수
3. index를 사용해서 배열 element에 접근 또는 객체에서 키로 값에 접근하는 것 → 상수
4. 반복문 루프가 있으면 `루프의 길이 * 루프 안에 있는 연산` <br/>
   👉 즉, n이 커질수록 루프가 반복되는 횟수가 늘어남

<br/>

> 🧐 <strong>공간 복잡도(Space Complexity)</strong>란? <br/>
> : 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간 <br/>
> (n이 커질수록 입력이 커진다는 것을 가정)

- 원시값(boolean, number, undefined, null) 👉 constant space(불변 공간) <br/>
  👉 입력 크기와 상관 없이 모두 불변 공간 즉, 똑같은 공간 차지

- 문자열과 참조타입(배열, 객체) 👉 `O(n)` 공간 필요

<br/>

✎ 로그함수란? 지수함수의 inverse

👍 알고리즘이 O(log n) 시간 복잡도를 갖고 있다면 good~

- 이진 로그를 대략적으로 계산하기 위해선 그 숫자가 1보다 작아지기 전에 2로 나눠지는 횟수 구하기 <br/>

<br/>

✅ O(1) < O(log n) < O(n) < O(nlog n) < O(n^2)

### 🤹‍♀️ Summary

1. 알고리즘의 성능을 분석하기 위해선 빅오 표기법 사용
2. 입력의 크기가 늘어날수록 전체적인 추세와 관련되어 있음
3. 정확도가 아닌 전체적인 추세를 중요하게 생각
4. 빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어 영향을 받지 않음
