// 2022.12.09(Fri)
// 땅따먹기.js

// my way
function solution(land) {
  // land.length: 3 => i = 1, 2 순회
  // index가 0 즉, 첫번째 행은 같은 열 중복 선택 조건을 만족하지 않아도 되므로 i는 1부터 시작해주기!
  for (let i = 1; i < land.length; i++) {
    // 열의 개수는 4개로 고정되어 있으므로 하나씩 일일이 정해줄 수 있음
    land[i][0] += Math.max(land[i - 1][1], land[i - 1][2], land[i - 1][3]); // 기존 land[0][0] = 5에서 Math.max(...) 값인 5를 더해서 10 | 4 + 12 = 16
    land[i][1] += Math.max(land[i - 1][0], land[i - 1][2], land[i - 1][3]); // 6 + 5 = 11 | 3 + 12 = 15
    land[i][2] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][3]); // 7 + 5 = 12 | 2 + 11 = 13
    land[i][3] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][2]); // 8 + 3 = 11 | 1 + 12 = 13
  }
  // land = [ [ 1, 2, 3, 5 ], [ 10, 11, 12, 11 ], [ 16, 15, 13, 13 ] ]
  return Math.max(...land[land.length - 1]); // 위의 행들의 같은 열을 제외한 값들의 합이 원소인 마지막 행에서 최댓값을 반환해주기!
}

// 같은 열 중복을 피하기 위해 위쪽 행에서 같은 열을 제외한 나머지 값들 중에서의 최댓값을 구해 더해준다.
// 마지막 행까지 연산이 끝나면 마지막 행 원소에는 각 자리에 위에서 부터 같은 열 중복 선택을 제외한 값들의 합이 위치하며, 여기서 최대값을 뽑아내면 된다!

console.log(
  solution([
    [1, 2, 3, 5],
    [5, 6, 7, 8],
    [4, 3, 2, 1],
  ])
); // 16

// 이 문제도 고냥 for문으로 이전 index만 겹치지 않도록 구하면 될거라고 생각했는데 아니였다,,
// DP를 이용해서 풀어야 하는 문제였음..!
